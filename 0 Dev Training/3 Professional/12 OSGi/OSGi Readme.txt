. 《OSGi与 Equinox - 创建高度模块化的Java系统》   Jeff McAffer   Paul Vanderlei    Simon Archer

   ZWTS\2014\Tp312JA\mca

   官网 :  http://OSGi.org

. 序

  1. 作为打包并部署的一个大型独立单元, WAR 文件 会放慢开发进程, 并使得组建大型开发团队变得更加困难, 因为在所有的东西可以部署之前, 必须用一个独立的打包步骤将它们放在一起.

  2. WAR 文件过于庞大和笨重 ---- 一个普通的企业级应用可能会依赖几百个第三方资源, 所有这些都要被打包到WAR文件中. 这会对上传和部署时间带来不利影响;

  3. 试图通过在同一容器中同时部署多个WAR文件来减少复杂度, 会导致 在JVM 中出现堆使用的问题, 因为每个WAR文件 都各自拷贝了所有的依赖资源, 而根本不考虑其中很多资源在理论上应被共享.

  4. 一起部署WAR文件时, 无法轻易共享公共服务.

  5. WAR文件作为最小的变更单元, 意味着在大型企业级应用中, 变更不能轻易被隔离盒包含.

  6. 在设计中尝试引入自我监控(即未实施) 的模块化约束 通常会失败, 尽管出发点是好的. 

. OSGi  -- 面向Java 的动态模块化系统

  OSGi 模块层 提供了将系统划分为独立模块的机制, 即Bundle， 它们可以独立打包、部署, 并有格子独立的生命周期.

. "篱笆筑的牢, 邻居处的好"

. OSGi 起源于 嵌入式技术领域, 延续了其精简的结构, 仅仅27个Java类型便构成了OSGi的核心规范.

. bundle 环境

  OSGi 系统由一系列称为 bundle 的组件构成. OSGi服务平台中执行的bundle 彼此独立, 通过一种设计精良的方式协同工作. bundle 本身是完全自描述的, 自行声明其公共的API, 自行定义在运行时环境下对其他bundle 的依赖, 同时隐藏其内部的具体实现.

  bundle 的作者(生产者) 创建了bundle 并使其能够被其他人所用. 系统集成者或者应用程序编写者(使用者) 都可以通过调用已有的API使用bundle 或者编写更多的bundle。 

  OSGi应用并不是自下而上 或自上而下的系统, 它仅仅是由一系列bundle 构成的集合.  在OSGi 应用中, 不存在主程序, 某些bundle 会提供代码库, 其他bundle 会启动线程、基于网络交互、访问数据库, 或者采用与其他bundle协作的方式访问硬件设备和系统资源. 与此同时, bundle之间 是存在依赖关系的, 通常情况下, 在协作式系统中bundle 间是相互平等的. 

. Java在定义和管理依赖方面不提供任何支持. 

  bundle 的具体实现形式仍然是jar, 但是在jar 的基础上增加了身份标识和依赖关系信息; 也就是说, bundle 是一种子描述的jar. 

  在默认的情况下, bundle 中的包对其他bundle 是不可见的. 按照约定, 如果其他bundle 大蒜使用某个包中的API, 那么包含该API的包必须显式的设置为"exported"(导出), 而使用 这些API 的代码所属的bundle 则需要设置一个相匹配的"import"(导入), 才能导入相匹配的包. 在概念上, 这种可见性管理与Java 中包的可见性个比较起来, 虽有类似, 但却更易管理, 也更为灵活.

  OSGi 在运行时会遵循这些可见性约束, 从而构成了一个松耦合但功能强大的模块化系统的基础。 

  bundle 导入某个包 仅仅是说明bundle 依赖于特定的包, 二不关心该包的提供者是那些bundle。 在运行环境下, bundle 的包依赖被解析, 由此bundle 被连接在一起, 基于的规则 包括  包名称、版本信息以及包匹配属性.   这种处理方式有效地消除了 类路径地狱(classpath hell)问题, 同时大大改善了类加载性能并降低了耦合度.

  没有绝对孤立的代码。 所有的松耦合都是有代价的。 在传统的Java 系统中, 如果你想使用某些功能, 只需要简单的引用所需要的类型.   这种紧耦合的方法虽然简单, 但有其局限性. 如果某一种场景需要更强的灵活性, 那么这种需求就无法满足.   

  Java 社区 中已经研究出不少临时或者部分的解决方法, 如 上下文环境类加载器、Class.forName、"服务"查询、日志打印, 等等. 所有者些例子都是为了能够实现松耦合组件间的协同工作. 

  包的导入导出仅是一种静态契约, 而服务(Service) 则用来促进动态协作. 服务其实就是对象, 用于实现一个契约或一种类型, 并且该服务在OSGi 中进行了注册. 在使用服务时, bundle 只需要导入定义该契约的包, 同时在OSGi 已经注册的服务中找到该契约的实现.  

  需要注意的是, 使用服务的bundle 既不需要知道服务的具体实现, 也不需要知道实现该服务的bundle---服务的接口和实现有可能会来自不同的bundle.  这样做, 使得整个系统仍然保持了松耦合的协作. 

  服务的动态性是与生俱来的: bundle 即可动态的注册, 也可以动态的注销其所能提供的服务, 与此同时, 它也可以在运行时保证这些约定的有效执行. 借助这些约定, 可以很容易的构造出 由 高内聚低耦合的 组件组织起来的应用程序. 

. bundle 剖析

  一个bundle 是由一系列的子描述文件组成的集合.

  bundle 的内容及相关需求的说明会在其 manifest 文件雪中表述, 即  META-INF/MANIFEST.MF 文件.  manifest文件遵循 标准 JAR manifest 语法, 但增加了一系列特定的OSGi头标识。

  处于管理的需要, OSGi 框架对每个bundle 提供了属于自己的类加载器, 以便对源自不同bundle 的类进行区分. 当bundle 被卸载或者更新时, 其自身的类加载器以及由该类加载器加载的所有类均 会被摒弃.  通过使用分立的类加载器, 系统可以在同一时刻加载同一个类的多个版本. 这种方式同样加强了标准Java 类型的可见性原则, 比如在bundle 中的包可见性和public 、proected 以及private 类型.

.  应用 >  bundle > 包 > 类型 > 方法

. bundle 生命周期

  安装 --> 启动 -> 停止 -> 更新 -> 卸载 

. 服务

  OSGi 的服务注册扮演了一个类似全局 的电子公告牌的角色, 主要用来协调如下三方之间的关系:

     定义服务接口的bundle

     实现服务接口并注册服务对象的bundle

     发现并使用服务的bundle

  服务注册时的这种协作 以 一种匿名 的方式进行 --- 提供某种服务的bundle 并不知道谁会用这一服务;  同样, 使用某个服务的bundle 并不知晓该服务的提供者是谁.

  服务是通过使用java 类来定义的, 通常就是 一个Java 接口. 该类必须是  public 且 其所在的包必须被声明导出. 其他的bundle, 甚至可能是其自身, 实现该服务定义的接口并将其实例化, 然后按照已经定义的服务接口名称将该实例注册为服务. 实现该服务的类, 即接口实现细节, 一般不放在导出包之中.

  最后, 一系列的第三方bundle 通过导入包含服务接口的包来使用可用的服务, 同时通过在注册服务中按照接口名称来 查找服务.   当获得了一个 已经匹配的服务对象时, 可以一直使用该服务, 知道使用完毕或者服务被注销.  

  需要注意的是, 多个bundle 可以同时使用同一个服务对象, 多个服务对象可以源自一个或多个bundle.

. 扩展 和扩展点

  Equinox  扩展注册 是一种补充机制, 支持 bundle 内部的相互协作. 在这种模型下, bundle 可以通过 声明一个扩展点( extension point)， 实现对其自身的扩展和配置. 这样的bundle 实质上在说:  “如果提前告诉我信息, 我将。。。”, 其他的bundle 随后会以扩展的方式， 向扩展点提供所需信息.

  P19

   "通过使用扩展注册来提供或发现不同的action。 在该方法中, 门户bundle 声明了一个actions 扩展点并定义了一个契约"  

   "bundle 可以通过使用某个路径、标签和类的方式实现IPortalAction接口, 进而提供actions 扩展, 定义门户action. 门户会根据指定的路径, 为用户呈现指定的标签, 这样用户点击标签时, 会访问一个特定的URL。 请求URL的结果是门户将实例化指定的action类, 并将其转化为IPortalAction, 同时调用其execute方法."

   扩展及扩展点的关系以XML格式定义在 plugin.xml文件中. 每一个参与的bundle 都有这样一个文件. 随着系统中的bundle 被解析, 它们的扩展及扩展点也随即被加载到扩展注册中, 其他 bundle 均可使用. 所有的扩展注册事件通过广播的方式传递给已注册的监听器. 通过编程的方式, 也能对扩展及扩展点进行管理. 

. P21 OSGi 框架实现

  Equinox -- 也许是使用最为广泛的开源OSGi规范实现.  Eclipse 中的工具、富客户端、服务器端以及嵌入式工程, 都采用 Equinox 作为运行时基础. 同时 它也是 核心框架规范、部分服务规范以及 JSR291 的参考实现.  Equinox 的使用需要遵循 Eclipse Public License， 网址: http://eclipse.org/equinox

  Felix  --- 源于 Oscar 项目. Apache 的开源项目. Felix 的使用需要遵守 Apache License v2. http://felix.apache.org

  Knopflerfish -- 开源项目, 支持 OSGi R4.x 规范, 提供一个框架及部分服务的实现. 需要遵守BSD刑事的license. http://knopflerfish.org

  mBedded Server --  商业化的基于 R4.x版本规范的实现, 目前已经广泛应用于嵌入式领域. 提供了一些额外的服务实现. 

       http://prosyst.com

 Concierge ---- 是一个高度精简化并优化了的OSGi R3.0 规范的实现, 适用于小型的嵌入式领域. 需要遵守BSD License。

       http://concierge.sourceforge.net

 尽管基础框架中包含了很多功能和特性, 但是真正的实现很小, 并且运行在最小的JVM实现中. Coneierge 只占用80K 的磁盘空间.  基本的R4.x 规范的实现需要占到 300K~600K 的磁盘空间.  

  作为 OSGi规范实现的Equinox, 在其基础JAR包中包含了相当多的扩展功能, 如优化的灵活性支持、高级签名管理、高可扩展性, 即便这样, 也仅占用了不足1M 的磁盘空间. 




  