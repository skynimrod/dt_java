. 参见:

      http://baike.baidu.com/link?url=GD2a0Q9YUAoT0E5Vo0zXHGG1FKjhLziSb7RwjqRylUVr85Pu7pTZhBf9zKob8pDEwJDy_ZZhrcnvHSXgtoBIja


### import java.security.*; 

  这个JAR包中包含了常用的很多加解密算法

. SHA1

  安全哈希算法(Secure Hash Algorithm) 主要适用于数字签名标准(Digital Signature Standard DSS) 里面定义的数字签名算法( Digital Signature Algorithm DSA)。 对于长度小于2^64位的消息,  SHA1 会产生一个160位的消息摘要.  当接收到消息的时候, 这个消息摘要可以用来验证数据的完整性. 在传输的过程中, 数据很可能发生变化, 那么这时候就会产生不同的消息摘要.  

  SHA1 有如下特性: 不可以从消息摘要中复原信息;  两个不同的消息不会产生同样的消息摘要.

. 术语和概念

  1.1 位，字节和字(Word)

      SHA1 始终把消息当成一个位(bit)字符串来处理. 在本文中, 一个字(Word) 是32位, 而一个字节(Byte) 是8位. 比如, 字符串"abc"可以被转换成一个位字符串: 01100001 01100010 01100011.  它也可以被表示成16进制字符串  0x616263

  1.2 运算符和符号

      下面的逻辑运算符都被运用于"字" (Word)

      X & Y = X,    逻辑与

      。。。。略

. 2. SHA1 算法描述

   在SHA1 算法中, 我们必须把原始消息(字符串,文件等) 转换成字 位字符串. SHA1 算法只接受位 作为输入. 假设我们对字符串"abc" 产生消息摘要. 首先, 我们将它转换成 位字符串如下:

      01100001 01100010 01100011

     -------------------------------

     'a' = 97  'b' = 98  'c' = 99
    
     这个位字符串的长度为24. 下面我们需要5个步骤来计算消息摘要MAC

  2.1 补位

     消息必须进行补位, 以使其长度在对512 取模 以后的余数 是448. 也就是说, (补位后的消息长度) % 512 = 448.  即使长度已经满足对512取模 后余数是448, 补位也必须要进行.

     补位是这样进行的: 先补一个1, 然后再补0, 知道长度满足对512取模后余数是448. 总而言之, 补位是至少补一位, 最多补512位. 还是以前面的"abc" 为例显示补位的过程.

    原始信息: 01100001 01100010 01100011

    补位第一步 : 01100001 01100010 01100011 1

        首先补一个"1"

    补位第二步: 01100001 01100010 01100011 10.....0

        然后补423个"0"   

    最后补位完成后的数据用16进制 是 下面的样子:

    61626380 00000000 00000000 00000000 
  
    00000000 00000000 00000000 00000000
  
    00000000 00000000 00000000 00000000
  
    00000000 00000000 

    经过以上的处理之后, 数据的长度是448了, 可以进行下一步操作.

  2.2 补长度

    所谓的补长度 是将 原始数据的长度 补到 已经进行了补位操作的 消息后面. 通常用一个64位的数据来表示原始消息的长度. 如果消息长度不大于2^64， 那么第一个字就是0. 在进行了补长度的操作以后, 整个消息就变成下面这样了(16进制格式)

    61626380 00000000 00000000 00000000        4字节 * 4 = 16字节
  
    00000000 00000000 00000000 00000000
  
    00000000 00000000 00000000 00000000
  
    00000000 00000000 00000000 00000018
  
    如果原始的消息长度超过了512. 我们需要将它补成512的倍数. 然后我们把整个消息分成一个一个512位的数据块, 分别处理每一个数据块, 从而得到消息摘要.

2.3 使用的常量

    一系列的常量字K(0), K(1), ... , K(79)，如果以16进制给出。它们如下：

    	Kt = 0x5A827999 (0 <= t <= 19)

	Kt = 0x6ED9EBA1 (20 <= t <= 39)

	Kt = 0x8F1BBCDC (40 <= t <= 59)
	
	Kt = 0xCA62C1D6 (60 <= t <= 79).

  2.4 需要使用的函数

    在SHA1中我们需要一系列的函数。每个函数ft (0 <= t <= 79)都操作32位字B，C，D并且产生32位字作为输出。ft(B,C,D)可以如下定义

	ft(B,C,D) = (B AND C) or ((NOT B) AND D) ( 0 <= t <= 19)

	ft(B,C,D) = B XOR C XOR D (20 <= t <= 39)

	ft(B,C,D) = (B AND C) or (B AND D) or (C AND D) (40 <= t <= 59)

	ft(B,C,D) = B XOR C XOR D (60 <= t <= 79).

  2.5 计算消息摘要

     必须使用进行了补位和补长度后的消息来计算消息摘要。计算需要两个缓冲区，每个都由5个32位的字组成，还需要一个80个32位字的缓冲区。第一个5个字的缓冲区被标识为A，B，C，D，E。第二个5个字的缓冲区被标识为H0, H1, H2, H3, H4。80个字的缓冲区被标识为W0, W1,..., W79

     另外还需要一个一个字的TEMP缓冲区。

     为了产生消息摘要，在第3.2部分中定义的512位（16字节）的数据块M1, M2,..., Mn

     会依次进行处理，处理每个数据块Mi 包含80个步骤。

     在处理每个数据块之前，缓冲区{Hi} 被初始化为下面的值（16进制）

     H0 = 0x67452301

     H1 = 0xEFCDAB89

     H2 = 0x98BADCFE

     H3 = 0x10325476

     H4 = 0xC3D2E1F0.

     现在开始处理M1, M2, ... , Mn。为了处理 Mi,需要进行下面的步骤

     (1). 将 Mi 分成 16 个字 W0, W1, ... , W15, W0 是最左边的字

     (2). 对于 t = 16 到 79 令 Wt = S1(Wt-3 XOR Wt-8 XOR Wt- 14 XOR Wt-16).

     (3). 令 A = H0, B = H1, C = H2, D = H3, E = H4.

     (4) 对于 t = 0 到 79，执行下面的循环

         TEMP = S5(A) + ft(B,C,D) + E + Wt + Kt;

         E = D; D = C; C = S30(B); B = A; A = TEMP;

     (5). 令 H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E.

      在处理完所有的 Mn, 后，消息摘要是一个160位的字符串，以下面的顺序标识

           H0 H1 H2 H3 H4.

      对于SHA256,SHA384,SHA512。你也可以用相似的办法来计算消息摘要。对消息进行补位的算法完全是一样的。

      SHA1在许多安全协议中广为使用，包括TLS和SSL、PGP、SSH、S/MIME和IPsec，曾被视为是MD5（更早之前被广为使用的散列函数）的后继者。

. SHA1 加密的例子

参见:

    http://heyun51.blog.163.com/blog/static/1782125320061027979320/


package other;

import java.security.*;

public class AddSHA1 {
    public static String SHA1(String inStr) {
        MessageDigest md = null;
        String outStr = null;
        try {
            md = MessageDigest.getInstance("SHA-1");     //选择SHA-1，也可以选择MD5
            byte[] digest = md.digest(inStr.getBytes());       //返回的是byet[]，要转化为String存储比较方便
            outStr = bytetoString(digest);
        }
        catch (NoSuchAlgorithmException nsae) {
            nsae.printStackTrace();
        }
        return outStr;
    }
    
    
    public static String bytetoString(byte[] digest) {
        String str = "";
        String tempStr = "";
        
        for (int i = 1; i < digest.length; i++) {
            tempStr = (Integer.toHexString(digest[i] & 0xff));
            if (tempStr.length() == 1) {
                str = str + "0" + tempStr;
            }
            else {
                str = str + tempStr;
            }
        }
        return str.toLowerCase();
    }
}
